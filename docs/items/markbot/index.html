<!doctype html><html lang=en-us>
<head>
<meta http-equiv=content-type content="text/html" charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="The personal website of Will Vesey, with projects, blog posts, and contact information">
<meta name=keywords content="Will,William,Vesey,website,projects,personal,github,resume,blog,tech">
<title>vesey.tech</title>
<style>/*!tailwindcss v2.2.19 | MIT License | https://tailwindcss.com*//*!modern-normalize v1.1.0 | MIT License | https://github.com/sindresorhus/modern-normalize*/*,::before,::after{box-sizing:border-box}html{-moz-tab-size:4;-o-tab-size:4;tab-size:4}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}body{font-family:system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji}hr{height:0;color:inherit}abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}button,[type=button]{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}button{background-color:transparent;background-image:none}fieldset{margin:0;padding:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,segoe ui,Roboto,helvetica neue,Arial,noto sans,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol,noto color emoji;line-height:1.5}body{font-family:inherit;line-height:inherit}*,::before,::after{box-sizing:border-box;border-width:0;border-style:solid;border-color:initial}hr{border-top-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input:-ms-input-placeholder,textarea:-ms-input-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit}pre,code,kbd,samp{font-family:JetBrains Mono,mono}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}*,::before,::after{--tw-border-opacity:1;border-color:rgba(229,231,235,var(--tw-border-opacity))}.prose{color:#374151;max-width:65ch}.prose a{color:#f9faf9;text-decoration:underline;font-weight:500}.prose strong{color:#eee8d5;font-weight:600}.prose ol[type=a]{--list-counter-style:lower-alpha}.prose ol[type=as]{--list-counter-style:lower-alpha}.prose ol[type=I]{--list-counter-style:upper-roman}.prose ol[type=i]{--list-counter-style:lower-roman}.prose ol[type=Is]{--list-counter-style:upper-roman}.prose ol[type=is]{--list-counter-style:lower-roman}.prose ol[type="1"]{--list-counter-style:decimal}.prose ol>li{position:relative;padding-left:1.75em}.prose ol>li::before{content:counter(list-item,var(--list-counter-style,decimal))".";position:absolute;font-weight:400;color:#6b7280;left:0}.prose ul>li{position:relative;padding-left:1.75em}.prose ul>li::before{content:"";position:absolute;background-color:#d1d5db;border-radius:50%;width:.375em;height:.375em;top:calc(.875em - .1875em);left:.25em}.prose hr{border-color:#e5e7eb;border-top-width:1px;margin-top:3em;margin-bottom:3em}.prose blockquote{font-weight:500;font-style:italic;color:#111827;border-left-width:.25rem;border-left-color:#e5e7eb;quotes:"\201C""\201D""\2018""\2019";margin-top:1.6em;margin-bottom:1.6em;padding-left:1em}.prose blockquote p:first-of-type::before{content:open-quote}.prose blockquote p:last-of-type::after{content:close-quote}.prose h1{color:#f9faf9;font-weight:800;font-size:2.25em;margin-top:0;margin-bottom:.8888889em;line-height:1.1111111}.prose h2{color:#f9faf9;font-weight:700;font-size:1.5em;margin-top:2em;margin-bottom:1em;line-height:1.3333333}.prose h3{color:#f9faf9;font-weight:600;font-size:1.25em;margin-top:1.6em;margin-bottom:.6em;line-height:1.6}.prose h4{color:#f9faf9;font-weight:600;margin-top:1.5em;margin-bottom:.5em;line-height:1.5}.prose figure figcaption{color:#6b7280;font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.prose code{color:#f9faf9;font-weight:600;font-size:.875em}.prose code::before{content:"`"}.prose code::after{content:"`"}.prose a code{color:#111827}.prose pre{color:#e5e7eb;background-color:#222d31;overflow-x:auto;font-size:.875em;line-height:1.7142857;margin-top:1.7142857em;margin-bottom:1.7142857em;border-radius:.375rem;padding-top:.8571429em;padding-right:1.1428571em;padding-bottom:.8571429em;padding-left:1.1428571em}.prose pre code{background-color:transparent;border-width:0;border-radius:0;padding:0;font-weight:400;color:inherit;font-size:inherit;font-family:inherit;line-height:inherit}.prose pre code::before{content:none}.prose pre code::after{content:none}.prose table{width:100%;table-layout:auto;text-align:left;margin-top:2em;margin-bottom:2em;font-size:.875em;line-height:1.7142857}.prose thead{color:#f9faf9;font-weight:600;border-bottom-width:1px;border-bottom-color:#d1d5db}.prose thead th{vertical-align:bottom;padding-right:.5714286em;padding-bottom:.5714286em;padding-left:.5714286em}.prose tbody tr{border-bottom-width:1px;border-bottom-color:#e5e7eb}.prose tbody tr:last-child{border-bottom-width:0}.prose tbody td{vertical-align:top;padding-top:.5714286em;padding-right:.5714286em;padding-bottom:.5714286em;padding-left:.5714286em}.prose{font-size:1rem;line-height:1.75}.prose p{margin-top:1.25em;margin-bottom:1.25em}.prose p code{background-color:#353836}.prose img{margin-top:2em;margin-bottom:2em}.prose video{margin-top:2em;margin-bottom:2em}.prose figure{margin-top:2em;margin-bottom:2em}.prose figure>*{margin-top:0;margin-bottom:0}.prose h2 code{font-size:.875em}.prose h3 code{font-size:.9em}.prose ol{margin-top:1.25em;margin-bottom:1.25em}.prose ul{margin-top:1.25em;margin-bottom:1.25em}.prose li{margin-top:.5em;margin-bottom:.5em}.prose>ul>li p{margin-top:.75em;margin-bottom:.75em}.prose>ul>li>*:first-child{margin-top:1.25em}.prose>ul>li>*:last-child{margin-bottom:1.25em}.prose>ol>li>*:first-child{margin-top:1.25em}.prose>ol>li>*:last-child{margin-bottom:1.25em}.prose ul ul,.prose ul ol,.prose ol ul,.prose ol ol{margin-top:.75em;margin-bottom:.75em}.prose hr+*{margin-top:0}.prose h2+*{margin-top:0}.prose h3+*{margin-top:0}.prose h4+*{margin-top:0}.prose thead th:first-child{padding-left:0}.prose thead th:last-child{padding-right:0}.prose tbody td:first-child{padding-left:0}.prose tbody td:last-child{padding-right:0}.prose>:first-child{margin-top:0}.prose>:last-child{margin-bottom:0}.prose h5{color:#f9faf9}.prose h6{color:#f9faf9}.prose div pre{background-color:#222d31!important}.prose-lg{font-size:1.125rem;line-height:1.7777778}.prose-lg p{margin-top:1.3333333em;margin-bottom:1.3333333em}.prose-lg blockquote{margin-top:1.6666667em;margin-bottom:1.6666667em;padding-left:1em}.prose-lg h1{font-size:2.6666667em;margin-top:0;margin-bottom:.8333333em;line-height:1}.prose-lg h2{font-size:1.6666667em;margin-top:1.8666667em;margin-bottom:1.0666667em;line-height:1.3333333}.prose-lg h3{font-size:1.3333333em;margin-top:1.6666667em;margin-bottom:.6666667em;line-height:1.5}.prose-lg h4{margin-top:1.7777778em;margin-bottom:.4444444em;line-height:1.5555556}.prose-lg img{margin-top:1.7777778em;margin-bottom:1.7777778em}.prose-lg video{margin-top:1.7777778em;margin-bottom:1.7777778em}.prose-lg figure{margin-top:1.7777778em;margin-bottom:1.7777778em}.prose-lg figure>*{margin-top:0;margin-bottom:0}.prose-lg figure figcaption{font-size:.8888889em;line-height:1.5;margin-top:1em}.prose-lg code{font-size:.8888889em}.prose-lg h2 code{font-size:.8666667em}.prose-lg h3 code{font-size:.875em}.prose-lg pre{font-size:.8888889em;line-height:1.75;margin-top:2em;margin-bottom:2em;border-radius:.375rem;padding-top:1em;padding-right:1.5em;padding-bottom:1em;padding-left:1.5em}.prose-lg ol{margin-top:1.3333333em;margin-bottom:1.3333333em}.prose-lg ul{margin-top:1.3333333em;margin-bottom:1.3333333em}.prose-lg li{margin-top:.6666667em;margin-bottom:.6666667em}.prose-lg ol>li{padding-left:1.6666667em}.prose-lg ol>li::before{left:0}.prose-lg ul>li{padding-left:1.6666667em}.prose-lg ul>li::before{width:.3333333em;height:.3333333em;top:calc(.8888889em - .1666667em);left:.2222222em}.prose-lg>ul>li p{margin-top:.8888889em;margin-bottom:.8888889em}.prose-lg>ul>li>*:first-child{margin-top:1.3333333em}.prose-lg>ul>li>*:last-child{margin-bottom:1.3333333em}.prose-lg>ol>li>*:first-child{margin-top:1.3333333em}.prose-lg>ol>li>*:last-child{margin-bottom:1.3333333em}.prose-lg ul ul,.prose-lg ul ol,.prose-lg ol ul,.prose-lg ol ol{margin-top:.8888889em;margin-bottom:.8888889em}.prose-lg hr{margin-top:3.1111111em;margin-bottom:3.1111111em}.prose-lg hr+*{margin-top:0}.prose-lg h2+*{margin-top:0}.prose-lg h3+*{margin-top:0}.prose-lg h4+*{margin-top:0}.prose-lg table{font-size:.8888889em;line-height:1.5}.prose-lg thead th{padding-right:.75em;padding-bottom:.75em;padding-left:.75em}.prose-lg thead th:first-child{padding-left:0}.prose-lg thead th:last-child{padding-right:0}.prose-lg tbody td{padding-top:.75em;padding-right:.75em;padding-bottom:.75em;padding-left:.75em}.prose-lg tbody td:first-child{padding-left:0}.prose-lg tbody td:last-child{padding-right:0}.prose-lg>:first-child{margin-top:0}.prose-lg>:last-child{margin-bottom:0}.absolute{position:absolute}.relative{position:relative}.inset-0{top:0;right:0;bottom:0;left:0}.block{display:block}.flex{display:flex}.table{display:table}.grid{display:grid}.h-full{height:100%}.h-screen{height:100vh}.w-full{width:100%}.w-screen{width:100vw}.max-w-none{max-width:none}.max-w-full{max-width:100%}.flex-1{flex:1}@-webkit-keyframes spin{to{transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}@-webkit-keyframes ping{75%,100%{transform:scale(2);opacity:0}}@keyframes ping{75%,100%{transform:scale(2);opacity:0}}@-webkit-keyframes pulse{50%{opacity:.5}}@keyframes pulse{50%{opacity:.5}}@-webkit-keyframes bounce{0%,100%{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:none;-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}@keyframes bounce{0%,100%{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:none;-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}.select-none{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.resize{resize:both}.grid-flow-row{grid-auto-flow:row}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-2{gap:.5rem}.divide-y-2>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(2px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(2px * var(--tw-divide-y-reverse))}.divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(1px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(1px * var(--tw-divide-y-reverse))}.overflow-hidden{overflow:hidden}.border{border-width:1px}.border-bg0{--tw-border-opacity:1;border-color:rgba(0,0,0,var(--tw-border-opacity))}.bg-bg2{--tw-bg-opacity:1;background-color:rgba(43,44,43,var(--tw-bg-opacity))}.hover\:bg-bg4:hover{--tw-bg-opacity:1;background-color:rgba(68,68,68,var(--tw-bg-opacity))}.p-2{padding:.5rem}.p-4{padding:1rem}.pt-8{padding-top:2rem}.pb-4{padding-bottom:1rem}.text-right{text-align:right}.font-mono{font-family:JetBrains Mono,mono}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.italic{font-style:italic}.text-fg1{--tw-text-opacity:1;color:rgba(249,250,249,var(--tw-text-opacity))}.underline{text-decoration:underline}*,::before,::after{--tw-shadow:0 0 #0000}*,::before,::after{--tw-ring-inset:var(--tw-empty,/*!*/ /*!*/);--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59, 130, 246, 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000}.filter{--tw-blur:var(--tw-empty,/*!*/ /*!*/);--tw-brightness:var(--tw-empty,/*!*/ /*!*/);--tw-contrast:var(--tw-empty,/*!*/ /*!*/);--tw-grayscale:var(--tw-empty,/*!*/ /*!*/);--tw-hue-rotate:var(--tw-empty,/*!*/ /*!*/);--tw-invert:var(--tw-empty,/*!*/ /*!*/);--tw-saturate:var(--tw-empty,/*!*/ /*!*/);--tw-sepia:var(--tw-empty,/*!*/ /*!*/);--tw-drop-shadow:var(--tw-empty,/*!*/ /*!*/);filter:var(--tw-blur)var(--tw-brightness)var(--tw-contrast)var(--tw-grayscale)var(--tw-hue-rotate)var(--tw-invert)var(--tw-saturate)var(--tw-sepia)var(--tw-drop-shadow)}.grayscale{--tw-grayscale:grayscale(100%)}.prose pre>code{white-space:pre-wrap!important}.prose p code{padding-left:.5rem;padding-right:.5rem}.prose p code::before{content:""}.prose p code::after{content:""}.prose img{width:100%}@font-face{font-family:jetbrains mono;src:url(https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono@2.242/fonts/webfonts/JetBrainsMono-Regular.woff2)format("woff2");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:jetbrains mono;src:url(https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono@2.242/fonts/webfonts/JetBrainsMono-Medium.woff2)format("woff2");font-weight:500;font-style:normal;font-display:swap}@font-face{font-family:jetbrains mono;src:url(https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono@2.242/fonts/webfonts/JetBrainsMono-SemiBold.woff2)format("woff2");font-weight:600;font-style:normal;font-display:swap}@font-face{font-family:jetbrains mono;src:url(https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono@2.242/fonts/webfonts/JetBrainsMono-Bold.woff2)format("woff2");font-weight:700;font-style:normal;font-display:swap}@font-face{font-family:jetbrains mono;src:url(https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono@2.242/fonts/webfonts/JetBrainsMono-ExtraBold.woff2)format("woff2");font-weight:800;font-style:normal;font-display:swap}@font-face{font-family:jetbrains mono;src:url(https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono@2.242/fonts/webfonts/JetBrainsMono-Light.woff2)format("woff2");font-weight:300;font-style:normal;font-display:swap}@font-face{font-family:jetbrains mono;src:url(https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono@2.242/fonts/webfonts/JetBrainsMono-ExtraLight.woff2)format("woff2");font-weight:200;font-style:normal;font-display:swap}@font-face{font-family:jetbrains mono;src:url(https://cdn.jsdelivr.net/gh/JetBrains/JetBrainsMono@2.242/fonts/webfonts/JetBrainsMono-Thin.woff2)format("woff2");font-weight:100;font-style:normal;font-display:swap}@media(min-width:640px){.sm\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}@media(min-width:768px){.md\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}}@media(min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}@media(min-width:1280px){.xl\:grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}}@media(min-width:1536px){}</style>
</head>
<body class=bg-bg2>
<main class="w-full h-full p-2 font-mono flex align-center">
<div class="w-full h-full p-2 font-mono flex flex-col items-center divide-y-2 select-none text-fg1">
<div class="flex-0 prose-lg max-w-none pb-4">
<h1>MarkBot</h1>
</div>
<article class="flex-1 prose max-w-full pt-8 text-fg1">
<p>I&rsquo;ve always had a love for large datasets and the interesting things one can do with them, so when my roommate sent me his entire Google Hangouts and Facebook chat history, I knew what I had to do.</p>
<h1 id=enter-markbot>Enter MarkBot</h1>
<h2 id=goals>Goals</h2>
<p>In the past, I&rsquo;ve implemented plenty of basic character-level RNNs and trained them on all sorts of text corpora, but this time I wanted to try something different, and utilize word embeddings to try and produce a more coherent Mark-based chatbot. My thought process goes like so:</p>
<ul>
<li>Word embeddings will allow the network to learn more abstract concepts beyond basic spelling and grammar, as it will not have to essentially memorize the spelling of each word in the English language (or rather, Mark&rsquo;s unique interpretation of the English language)</li>
<li>Word embeddings also have the advantage that similar words will lie close to each other in the vector space, so a conversational model will likely be more coherent, as it is predicting based on <strong>meaning</strong> rather than on <strong>spelling</strong></li>
</ul>
<h2 id=libraries>Libraries</h2>
<p>I&rsquo;ve used Python for the sake of brevity and ease of use, here are some of the libraries I&rsquo;ve used:</p>
<ul>
<li><a href=https://github.com/tqdm/tqdm>tqdm</a> - A great progress-bar library for the tedious <em>for</em> loops one often encounters when dealing with large datasets</li>
<li><a href=https://github.com/fchollet/keras>keras</a> - An easy-to-use deep learning tool that can sit on top of several of the most popular Python tensor mathematics libraries (I used Theano for my backend)</li>
<li><a href=https://github.com/nltk/nltk>nltk</a> - A handy collection of NLP tools</li>
<li><a href=https://github.com/maciejkula/glove-python>python-glove</a> - I have chosen GloVe over word2vec because of some slight and entirely unsubstantiated performance benefits I read about on the Internet somewhere<sup>[<strong>citation needed</strong>]</sup></li>
</ul>
<h2 id=the-project>The Project</h2>
<h3 id=parsing>Parsing</h3>
<p>In addition to Mark&rsquo;s Google Hangouts dump, I regularly back up my entire Facebook chat history, which I incorporated.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Loading datasets&#34;</span>)
<span style=font-weight:700;text-decoration:underline>with</span> <span style=font-weight:700;font-style:italic>open</span>(<span style=color:#666;font-style:italic>&#34;/home/will/Desktop/Python/Facebook.pkl&#34;</span>,<span style=color:#666;font-style:italic>&#34;rb&#34;</span>) <span style=font-weight:700;text-decoration:underline>as</span> f: facebook = pickle.loads(f.read())
<span style=font-weight:700;text-decoration:underline>with</span> <span style=font-weight:700;font-style:italic>open</span>(<span style=color:#666;font-style:italic>&#34;/home/will/Desktop/mark_hangouts.json&#34;</span>, <span style=color:#666;font-style:italic>&#34;r&#34;</span>) <span style=font-weight:700;text-decoration:underline>as</span> f: hangouts = json.loads(f.read())

sentences = []

<span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Parsing Facebook data&#34;</span>)
mark_uid = <span style=color:#666;font-style:italic>&#39;1750122188&#39;</span>
<span style=font-weight:700;text-decoration:underline>for</span> t, ms <span style=font-weight:700>in</span> tqdm(facebook[<span style=color:#666;font-style:italic>&#34;messages&#34;</span>].items()):
    ms = ms[::-1]
    <span style=font-weight:700;text-decoration:underline>for</span> idx, m <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(ms):
        <span style=font-weight:700;text-decoration:underline>if</span> <span style=font-weight:700>not</span> m.text:
            <span style=font-weight:700;text-decoration:underline>continue</span>
        text = m.text
        <span style=font-weight:700;text-decoration:underline>if</span> <span style=font-weight:700>not</span> text:
            <span style=font-weight:700;text-decoration:underline>continue</span>
        is_mark = m.author == mark_uid
        sentences.append((text, is_mark))

<span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Parsing Hangouts data&#34;</span>)
mark_chatid = <span style=color:#666;font-style:italic>&#34;116404337397755400265&#34;</span>
<span style=font-weight:700;text-decoration:underline>for</span> t <span style=font-weight:700>in</span> tqdm(hangouts[<span style=color:#666;font-style:italic>&#34;conversation_state&#34;</span>]):
    ms = t[<span style=color:#666;font-style:italic>&#34;conversation_state&#34;</span>][<span style=color:#666;font-style:italic>&#34;event&#34;</span>]
    <span style=font-weight:700;text-decoration:underline>for</span> idx, m <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(ms):
        <span style=font-weight:700;text-decoration:underline>if</span> <span style=color:#666;font-style:italic>&#34;chat_message&#34;</span> <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> m <span style=font-weight:700>or</span> <span style=color:#666;font-style:italic>&#34;segment&#34;</span> <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> m[<span style=color:#666;font-style:italic>&#34;chat_message&#34;</span>][<span style=color:#666;font-style:italic>&#34;message_content&#34;</span>]:
            <span style=font-weight:700;text-decoration:underline>continue</span>
        text = <span style=color:#666;font-style:italic>&#34;</span><span style=color:#666;font-style:italic>\n</span><span style=color:#666;font-style:italic>&#34;</span>.join(segment[<span style=color:#666;font-style:italic>&#34;text&#34;</span>] <span style=font-weight:700;text-decoration:underline>for</span> segment <span style=font-weight:700>in</span> m[<span style=color:#666;font-style:italic>&#34;chat_message&#34;</span>][<span style=color:#666;font-style:italic>&#34;message_content&#34;</span>][<span style=color:#666;font-style:italic>&#34;segment&#34;</span>] <span style=font-weight:700;text-decoration:underline>if</span> <span style=color:#666;font-style:italic>&#34;text&#34;</span> <span style=font-weight:700>in</span> segment)
        <span style=font-weight:700;text-decoration:underline>if</span> <span style=font-weight:700>not</span> text:
            <span style=font-weight:700;text-decoration:underline>continue</span>
        is_mark = m[<span style=color:#666;font-style:italic>&#34;sender_id&#34;</span>][<span style=color:#666;font-style:italic>&#34;chat_id&#34;</span>] == mark_chatid
        sentences.append((text, is_mark))
<span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Loaded&#34;</span>, <span style=font-weight:700;font-style:italic>len</span>(sentences), <span style=color:#666;font-style:italic>&#34;sentences&#34;</span>)
<span style=font-weight:700;text-decoration:underline>del</span> facebook, hangouts
</code></pre></div><p>TL;DR: Parsing Google Hangouts JSON is a pain and a half. Also, I tend to throw PEP out the window when it comes to single-use projects like this.</p>
<p>What this code does:</p>
<ul>
<li>Combines subsequent messages from one user into a single message</li>
<li>Prepares a list of sentences with both text data and an <em>is_mark</em> boolean, which is fairly self-explanatory. This allows us to build (question, response) tuples later</li>
<li>Delete references to things we don&rsquo;t need after the fact</li>
</ul>
<p><b></b></p>
<pre><code>&gt;&gt; sentences
[
 (&quot;Hey mark what's up?&quot;, False),
 (&quot;Not much, how about you?&quot;, True),
 ...
]
</code></pre>
<h3 id=tokenizing>Tokenizing</h3>
<p>Now let&rsquo;s separate messages into their constituent words, or <em>tokens</em></p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Tokenizing messages&#34;</span>)
<span style=font-weight:700;text-decoration:underline>import</span> <span style=color:#666;font-weight:700;font-style:italic>collections</span>
<span style=font-weight:700;text-decoration:underline>import</span> <span style=color:#666;font-weight:700;font-style:italic>nltk</span>

sentences = [(s[0].lower(), s[1]) <span style=font-weight:700;text-decoration:underline>for</span> s <span style=font-weight:700>in</span> sentences]
vocab = collections.defaultdict(<span style=font-weight:700;text-decoration:underline>lambda</span>: 0)
<span style=font-weight:700;text-decoration:underline>for</span> idx, s <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(tqdm(sentences)):
    words = nltk.word_tokenize(s[0])
    sentences[idx] = (words, s[1])
    <span style=font-weight:700;text-decoration:underline>for</span> w <span style=font-weight:700>in</span> words:
        vocab[w] += 1
vocab = <span style=font-weight:700;font-style:italic>dict</span>(vocab)
<span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;</span><span style=color:#666;font-style:italic>{}</span><span style=color:#666;font-style:italic> unfiltered vocabulary words&#34;</span>.format(<span style=font-weight:700;font-style:italic>len</span>(vocab)))
</code></pre></div><p>What this code does:</p>
<ul>
<li>Lower-cases and tokenizes all the messages</li>
<li>Counts word frequencies</li>
</ul>
<p>By lower-casing the messages, we reduce the vocabulary size, as otherwise &ldquo;Car&rdquo; and &ldquo;car&rdquo; would be interpreted as different words</p>
<p><b></b></p>
<pre><code>&gt;&gt; sentences
[
 ([&quot;hey&quot;, &quot;mark&quot;, &quot;what&quot;, &quot;'s&quot;, &quot;up&quot;, &quot;?&quot;], False),
 ([&quot;not&quot;, &quot;much&quot;, &quot;,&quot;, &quot;how&quot;, &quot;about&quot;, &quot;you&quot;, &quot;?&quot;], True),
 ...
]
</code></pre>
<h3 id=query-response>Query, Response</h3>
<p>Now I need to form (query, response) tuples if this is going to work as a conversational model. This is when we&rsquo;ll use the <em>is_mark</em> bool.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Assembling response training data&#34;</span>)
<span style=font-weight:700;text-decoration:underline>import</span> <span style=color:#666;font-weight:700;font-style:italic>random</span>

BOS, EOS = <span style=color:#666;font-style:italic>&#34;</span><span style=color:#666;font-style:italic>\x00</span><span style=color:#666;font-style:italic>&#34;</span>, <span style=color:#666;font-style:italic>&#34;</span><span style=color:#666;font-style:italic>\x01</span><span style=color:#666;font-style:italic>&#34;</span>
exchanges = []
idxs = [idx <span style=font-weight:700;text-decoration:underline>for</span> idx, s <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(sentences) <span style=font-weight:700;text-decoration:underline>if</span> s[1] <span style=font-weight:700>and</span> idx &gt;= CONTEXT_LINES]
sentences = [s[0] <span style=font-weight:700;text-decoration:underline>for</span> s <span style=font-weight:700>in</span> sentences]
<span style=color:#888;font-style:italic>#Also perform pruning to remove query/response pairs with uncommon words</span>
prune = <span style=font-weight:700;font-style:italic>set</span>([w <span style=font-weight:700;text-decoration:underline>for</span> w <span style=font-weight:700>in</span> vocab <span style=font-weight:700;text-decoration:underline>if</span> vocab[w] &lt; 9])
<span style=font-weight:700;text-decoration:underline>for</span> idx <span style=font-weight:700>in</span> idxs:
    exchange = [s <span style=font-weight:700;text-decoration:underline>for</span> s <span style=font-weight:700>in</span> sentences[idx-CONTEXT_LINES: idx+1]]
    exchange[-1] = [BOS] + exchange[-1] + [EOS]
    <span style=font-weight:700;text-decoration:underline>if</span> <span style=font-weight:700;font-style:italic>any</span>([w <span style=font-weight:700>in</span> prune <span style=font-weight:700;text-decoration:underline>for</span> s <span style=font-weight:700>in</span> exchange <span style=font-weight:700;text-decoration:underline>for</span> w <span style=font-weight:700>in</span> s]):
        <span style=font-weight:700;text-decoration:underline>continue</span>
    <span style=font-weight:700;text-decoration:underline>else</span>:
        exchanges.append(exchange)
sentences = [s <span style=font-weight:700;text-decoration:underline>for</span> e <span style=font-weight:700>in</span> exchanges <span style=font-weight:700;text-decoration:underline>for</span> s <span style=font-weight:700>in</span> e]
exchanges = [([w <span style=font-weight:700;text-decoration:underline>for</span> s <span style=font-weight:700>in</span> e[:-1] <span style=font-weight:700;text-decoration:underline>for</span> w <span style=font-weight:700>in</span> s], e[-1]) <span style=font-weight:700;text-decoration:underline>for</span> e <span style=font-weight:700>in</span> exchanges]
random.shuffle(exchanges)

<span style=color:#888;font-style:italic>#Now recompute our vocabulary</span>
vocab = collections.defaultdict(<span style=font-weight:700;text-decoration:underline>lambda</span>: 0)
<span style=font-weight:700;text-decoration:underline>for</span> s <span style=font-weight:700>in</span> sentences:
    <span style=font-weight:700;text-decoration:underline>for</span> w <span style=font-weight:700>in</span> s:
        vocab[w] += 1
vocab = <span style=font-weight:700;font-style:italic>dict</span>(vocab)
<span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;</span><span style=color:#666;font-style:italic>{}</span><span style=color:#666;font-style:italic> query/response pairs</span><span style=color:#666;font-style:italic>\n</span><span style=color:#666;font-style:italic>{}</span><span style=color:#666;font-style:italic> vocabulary words&#34;</span>.format(<span style=font-weight:700;font-style:italic>len</span>(exchanges), <span style=font-weight:700;font-style:italic>len</span>(vocab)-2))
</code></pre></div><p>A few things are happening here:</p>
<ul>
<li>(query, response) tuples, or <strong>exchanges</strong>, are prepared</li>
<li>Exchanges with uncommon vocabulary are discarded. In this dataset, uncommon vocabulary mostly manifests in the form of esoteric emoji, which I don&rsquo;t particularly need this conversational model to reproduce.
<br>
Like I said, this data merely represents Mark&rsquo;s unique subset of the English language (or rather, the two sets intersect but also contain elements unique to themselves, as I do not believe &lsquo;üòç&rsquo; is in the OED, nor have I ever heard Mark say &lsquo;lexiphanicism&rsquo;, though he is certainly prone to it)</li>
<li>Beginning-of-sequence and end-of-sequence markers are inserted into the response element, for use later in the neural chatbot model</li>
<li>Finally, the vocabulary is recomputed to account for the removal of exchanges containing uncommon vocabulary. I could have simply replaced these uncommon words with an unknown-word token, but thought it would be cleaner to not go that route.</li>
</ul>
<p>This is what the data looks like now:</p>
<pre><code>&gt;&gt; exchanges
[
 (
  [&quot;hey&quot;, &quot;mark&quot;, &quot;what&quot;, &quot;'s&quot;, &quot;up&quot;, &quot;?&quot;],
  [&quot;\x00&quot;, &quot;not&quot;, &quot;much&quot;, &quot;,&quot;, &quot;how&quot;, &quot;about&quot;, &quot;you&quot;, &quot;?&quot;, &quot;\x01&quot;]
 ),
 ...
]
</code></pre>
<h3 id=converting-to-indices>Converting to Indices</h3>
<p>Now let&rsquo;s turn these words into numbers!</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#888;font-style:italic>#The lower a word&#39;s lookup index, the higher its frequency in the corpus</span>
<span style=font-weight:700;text-decoration:underline>import</span> <span style=color:#666;font-weight:700;font-style:italic>keras</span>
<span style=font-weight:700;text-decoration:underline>from</span> <span style=color:#666;font-weight:700;font-style:italic>keras.preprocessing.sequence</span> <span style=font-weight:700;text-decoration:underline>import</span> pad_sequences
lookup_table =      {idx: w <span style=font-weight:700;text-decoration:underline>for</span> idx, w <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(<span style=font-weight:700;font-style:italic>sorted</span>(vocab, key=<span style=font-weight:700;text-decoration:underline>lambda</span> w: vocab[w])[::-1])}
lookup_table.update({w: idx <span style=font-weight:700;text-decoration:underline>for</span> idx, w <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(<span style=font-weight:700;font-style:italic>sorted</span>(vocab, key=<span style=font-weight:700;text-decoration:underline>lambda</span> w: vocab[w])[::-1])})
X = np.asarray([[lookup_table[w] <span style=font-weight:700;text-decoration:underline>for</span> w <span style=font-weight:700>in</span> query] <span style=font-weight:700;text-decoration:underline>for</span> query <span style=font-weight:700>in</span> (r[0] <span style=font-weight:700;text-decoration:underline>for</span> r <span style=font-weight:700>in</span> exchanges)])
Y = np.asarray([[lookup_table[w] <span style=font-weight:700;text-decoration:underline>for</span> w <span style=font-weight:700>in</span> response] <span style=font-weight:700;text-decoration:underline>for</span> response <span style=font-weight:700>in</span> (r[1] <span style=font-weight:700;text-decoration:underline>for</span> r <span style=font-weight:700>in</span> exchanges)])
X = pad_sequences(X, SEQUENCE_LEN)
Y = pad_sequences(Y, SEQUENCE_LEN, padding=<span style=color:#666;font-style:italic>&#34;post&#34;</span>)
</code></pre></div><ul>
<li>
<p>Firstly, the lookup table simply maps words to their indexes and back again</p>
</li>
<li>
<p>The X and Y variables now contain the query, response data but in index format, and padded to length</p>
<pre tabindex=0><code>&gt;&gt; X 
array([
       [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0, 262,  73,  28,  19,  44,   4
       ],
       ...
      ], dtype=int32 )

&gt;&gt; Y
array([
       [  1,  31, 107,  10,  54,  76,   9,   4,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0
       ],
       ...
      ], dtype=int32 )
</code></pre></li>
</ul>
<p>We are still dealing with words here though, the integers in X and Y do not encode any meaning. That comes next.</p>
<p>As you can see, queries are padded at the <strong>beginning</strong> and responses are padded at the <strong>end</strong>, so you can see that we&rsquo;re going to be feeding it a certain amount of context and expecting some variable amount of response, stopping when we hit the 0&rsquo;s (which represent end-of-sequence markers)</p>
<h3 id=vectorization>Vectorization</h3>
<p>The fun begins! Now we are going to train with the GloVe algorithm to embed our words into a high dimensional space that encodes semantic content and relationships.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Building vocabulary model&#34;</span>)
<span style=font-weight:700;text-decoration:underline>import</span> <span style=color:#666;font-weight:700;font-style:italic>glove</span>
<span style=font-weight:700;text-decoration:underline>import</span> <span style=color:#666;font-weight:700;font-style:italic>multiprocessing</span>

corpus = glove.Corpus()
corpus.fit(sentences, window=10)
glove_model = glove.Glove(no_components=WORD_EMBEDDING_COMPONENTS, learning_rate=0.05)
glove_model.fit(corpus.matrix, epochs=30, no_threads=multiprocessing.cpu_count(), verbose=<span style=font-weight:700;text-decoration:underline>True</span>)
<span style=font-weight:700;text-decoration:underline>del</span> sentences    
</code></pre></div><p>The model has now been trained on the available sentences and we can do useful things with the resulting word embeddings! But we&rsquo;re not going to. Instead we&rsquo;re going to virtualize my roommate.</p>
<h3 id=building-the-neural-model>Building the neural model</h3>
<p>We&rsquo;re into the thick of it now. I have adapted a model I found <a href=https://github.com/oswaldoludwig/Seq2seq-Chatbot-for-Keras>here</a> that implements a sequence-to-sequence architecture.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Building neural chatbot model&#34;</span>)
optimizer = keras.optimizers.Adam(lr=0.001) 
input_context = keras.layers.Input(shape=(SEQUENCE_LEN,), dtype=<span style=color:#666;font-style:italic>&#39;int32&#39;</span>, name=<span style=color:#666;font-style:italic>&#39;input_context&#39;</span>)
inputanswer_chunkanswer = keras.layers.Input(shape=(SEQUENCE_LEN,), dtype=<span style=color:#666;font-style:italic>&#39;int32&#39;</span>, name=<span style=color:#666;font-style:italic>&#39;inputanswer_chunkanswer&#39;</span>)
LSTM_encoder = keras.layers.LSTM(SENTENCE_EMBEDDING_SIZE, kernel_initializer=<span style=color:#666;font-style:italic>&#39;lecun_uniform&#39;</span>)
LSTM_decoder = keras.layers.LSTM(SENTENCE_EMBEDDING_SIZE, kernel_initializer=<span style=color:#666;font-style:italic>&#39;lecun_uniform&#39;</span>)
Shared_Embedding = keras.layers.Embedding(output_dim=glove_model.no_components, input_dim=<span style=font-weight:700;font-style:italic>len</span>(vocab), weights=[glove_model.word_vectors.copy()], input_length=SEQUENCE_LEN)
word_embedding_context = Shared_Embedding(input_context)
context_embedding = LSTM_encoder(word_embedding_context)
word_embeddinganswer_chunknswer = Shared_Embedding(inputanswer_chunkanswer)
answer_embedding = LSTM_decoder(word_embeddinganswer_chunknswer)
merge_layer = keras.layers.concatenate([context_embedding, answer_embedding], axis=1)
<span style=color:#888;font-style:italic>#We can change the number of neurons in this Dense layer</span>
out = keras.layers.Dense(<span style=font-weight:700;font-style:italic>len</span>(vocab)//2, activation=<span style=color:#666;font-style:italic>&#34;relu&#34;</span>)(merge_layer)
out = keras.layers.Dense(<span style=font-weight:700;font-style:italic>len</span>(vocab), activation=<span style=color:#666;font-style:italic>&#34;softmax&#34;</span>)(out)
keras_model = keras.models.Model(inputs=[input_context, inputanswer_chunkanswer], outputs=[out])
keras_model.compile(loss=<span style=color:#666;font-style:italic>&#39;categorical_crossentropy&#39;</span>, optimizer=optimizer)
<span style=font-weight:700;text-decoration:underline>del</span> glove_model
</code></pre></div><p>This graphic gives the general idea - we&rsquo;re feeding in both the query and the response so far into the network to get the next word in the response</p>
<p><img src=https://raw.githubusercontent.com/oswaldoludwig/Seq2seq-Chatbot-for-Keras/master/model_graph.png alt="alt text" title="[again, not mine]"></p>
<p>At this point, a word looks like this:</p>
<pre><code>array([ 0.06541251, -0.60211362,  0.19668873,  0.29943736, -0.04908019,
       -0.25159775, -0.48105127,  0.18929953, -0.35931338,  0.21183521,
        0.32535496,  0.24972419,  0.09867496,  0.28443115,  0.50898685,
       -0.04326349,  0.10213821, -0.14590992,  0.33488042, -0.14846319,
       -0.1409087 , -0.19627512,  0.27064866,  0.30814872,  0.44088078,
       -0.39964452,  0.2399658 , -0.13583342,  0.02606956,  0.30684316,
       -0.12864215,  0.10482805,  0.28297046,  0.07438818, -0.29477953,
        0.10404356, -0.32852114, -0.09728817, -0.20320519,  0.18048016,
        0.37241584,  0.15531563,  0.16767227, -0.02549689,  0.24815189,
       -0.11939143, -0.29207007,  0.26256024,  0.41336682,  0.23037289,
       -0.23548023, -0.16578295,  0.00896039,  0.20869134, -0.14342295,
       -0.23251574,  0.40983124,  0.19986974,  0.16265753, -0.18266805,
       -0.1975813 , -0.33908948,  0.18949206, -0.11479648,  0.35812903,
       -0.16103889,  0.14967493,  0.30761199,  0.31005254, -0.04312443,
       -0.04538435, -0.21032511, -0.18207666, -0.27363791, -0.00809431,
       -0.16818864, -0.12332384, -0.2938934 , -0.2526425 , -0.23394612,
        0.53925823,  0.31640659,  0.62309644,  0.28594853, -0.39425204,
       -0.1976824 , -0.14072738, -0.51376977,  0.18433504, -0.04015992,
        0.26220768, -0.13670408,  0.15177998,  0.27146796,  0.03903609,
       -0.06253815,  0.42974848,  0.30019652, -0.05678444,  0.18900654])
</code></pre>
<h3 id=training-the-neural-model>Training the neural model</h3>
<p>We have to do a lot of chunking here because the size of the arrays we&rsquo;re creating is so large that I keep running out of RAM</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>chunk_size = X.shape[0] // NUM_CHUNKS
<span style=font-weight:700;text-decoration:underline>for</span> epoch <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>range</span>(EPOCHS):
    <span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Training epoch </span><span style=color:#666;font-style:italic>{}</span><span style=color:#666;font-style:italic>/</span><span style=color:#666;font-style:italic>{}</span><span style=color:#666;font-style:italic>&#34;</span>.format(epoch+1, EPOCHS))
    <span style=font-weight:700;text-decoration:underline>try</span>:
        <span style=font-weight:700;text-decoration:underline>for</span> chunk_idx, chunk <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(<span style=font-weight:700;font-style:italic>range</span>(0, <span style=font-weight:700;font-style:italic>len</span>(X), chunk_size)):
            <span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Training chunk </span><span style=color:#666;font-style:italic>{}</span><span style=color:#666;font-style:italic>&#34;</span>.format(chunk_idx+1))
            X_chunk = X[chunk: chunk+chunk_size]
            Y_chunk = Y[chunk: chunk+chunk_size]

            total_unpadded_len = 0
            <span style=font-weight:700;text-decoration:underline>for</span> i, y <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(Y_chunk):
                unpadded_len = np.where(y == lookup_table[EOS])[0][0]
                total_unpadded_len += unpadded_len + 1

            context_chunk = np.zeros((total_unpadded_len, SEQUENCE_LEN))
            answer_chunk = np.zeros((total_unpadded_len, SEQUENCE_LEN))
            next_word_chunk = np.zeros((total_unpadded_len, <span style=font-weight:700;font-style:italic>len</span>(vocab)))

            count = 0
            <span style=font-weight:700;text-decoration:underline>for</span> i, y <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>enumerate</span>(Y_chunk):
                <span style=color:#888;font-style:italic>#Prepare one-hot encoding</span>
                answer_partial = np.zeros((1, SEQUENCE_LEN))
                limit = np.where(y == lookup_table[EOS])[0][0]

                <span style=font-weight:700;text-decoration:underline>for</span> symbol_idx <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>range</span>(1, limit+1):
                    one_hot = np.zeros((1, <span style=font-weight:700;font-style:italic>len</span>(vocab)))
                    one_hot[0, y[symbol_idx]] = 1

                    answer_partial[0, -symbol_idx:] = y[0: symbol_idx]

                    context_chunk[count, :] = X_chunk[i: i+1]
                    answer_chunk[count, :] = answer_partial
                    next_word_chunk[count, :] = one_hot
                    count += 1

            keras_model.fit([context_chunk, answer_chunk], next_word_chunk, batch_size=BATCH_SIZE, epochs=1)
            <span style=font-weight:700;text-decoration:underline>del</span> context_chunk, answer_chunk, next_word_chunk

    <span style=font-weight:700;text-decoration:underline>except</span> KeyboardInterrupt:
        <span style=font-weight:700;text-decoration:underline>break</span>
</code></pre></div><p>This code is training the neural network bit by bit so it learns how to converse, given a query and a partial answer.</p>
<p>For example, given the vector arrays for the query string &ldquo;what is your name&rdquo; and partial answer string &ldquo;my name is&rdquo;, it would output a vector that is very close to the vector for the word &ldquo;mark&rdquo; (assuming Mark has answered this question often enough for it to learn that response)</p>
<p>Now all we have to do is test it!</p>
<h3 id=testing-the-chatbot>Testing the chatbot!</h3>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=font-weight:700;font-style:italic>print</span>(<span style=color:#666;font-style:italic>&#34;Testing chatbot&#34;</span>)
<span style=color:#888;font-style:italic>#Helper function to sample an index from an array of probabilities</span>
<span style=font-weight:700;text-decoration:underline>def</span> <span style=color:#666;font-weight:700;font-style:italic>sample</span>(preds, temperature=1.0):
    preds = np.asarray(preds).astype(<span style=color:#666;font-style:italic>&#39;float64&#39;</span>)
    preds = np.log(preds) / temperature
    exp_preds = np.exp(preds)
    preds = exp_preds / np.sum(exp_preds)
    probas = np.random.multinomial(1, preds, 1)
    <span style=font-weight:700;text-decoration:underline>return</span> np.argmax(probas)

<span style=font-weight:700;text-decoration:underline>def</span> <span style=color:#666;font-weight:700;font-style:italic>ask</span>(query, temperature=0.3):
    <span style=font-weight:700;font-style:italic>print</span>(query)
    query = np.asarray([lookup_table[w] <span style=font-weight:700;text-decoration:underline>for</span> w <span style=font-weight:700>in</span> nltk.word_tokenize(query.lower())])
    <span style=color:#888;font-style:italic>#Pad to length of query sentence</span>
    query = np.pad(query[-SEQUENCE_LEN:], pad_width=(SEQUENCE_LEN-<span style=font-weight:700;font-style:italic>len</span>(query), 0), mode=<span style=color:#666;font-style:italic>&#34;constant&#34;</span>)
    query = np.asarray([query])

    response = np.zeros((1, SEQUENCE_LEN))
    <span style=color:#888;font-style:italic>#Insert BOS marker</span>
    response[0, -1] = lookup_table[BOS]
    <span style=font-weight:700;text-decoration:underline>for</span> k <span style=font-weight:700>in</span> <span style=font-weight:700;font-style:italic>range</span>(SEQUENCE_LEN - 1):
        pred = keras_model.predict([query, response])[0]
        next_token = sample(pred, temperature)
        <span style=color:#888;font-style:italic>#Shift partial answer over one</span>
        response[0, :-1] = response[0, 1:]
        response[0, -1] = next_token
        <span style=color:#888;font-style:italic>#Is the model telling us to end the sentence?</span>
        <span style=font-weight:700;text-decoration:underline>if</span> next_token == lookup_table[EOS]:
            <span style=font-weight:700;text-decoration:underline>break</span>

    response = <span style=color:#666;font-style:italic>&#34; &#34;</span>.join([lookup_table[<span style=font-weight:700;font-style:italic>int</span>(token)] <span style=font-weight:700;text-decoration:underline>for</span> token <span style=font-weight:700>in</span> response[0] <span style=font-weight:700;text-decoration:underline>if</span> token <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> (lookup_table[BOS], lookup_table[EOS])])
    <span style=font-weight:700;font-style:italic>print</span>(response)

ask(<span style=color:#666;font-style:italic>&#34;What is the meaning of life?&#34;</span>)
</code></pre></div><p>The sample function allows us to introduce some uncertainty into the reply, so it&rsquo;s not the same every time.</p>
<p>And the response, after the default 10 epochs of training?</p>
<pre><code>&gt;&gt; ask(&quot;What is the meaning of life?&quot;)
i do n't know what i 'm doing
</code></pre>
<p>Overfitting aside, that sure sounds like Mark.</p>
<p><em>YMMV</em></p>
</article>
</div>
</main>
</body>
</html>